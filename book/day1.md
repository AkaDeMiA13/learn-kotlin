# 1日目

## 基本型
### 数値
Kotlin には組み込みで以下の型が提供される．

- 整数

    | 型      | ビット |
    | :------ | :----: |
    | `Long`  |   64   |
    | `Int`   |   32   |
    | `Short` |   16   |
    | `Byte`  |   8    |

- 実数（浮動小数点数）

    | 型       | ビット |
    | :------- | :----: |
    | `Double` |   64   |
    | `Float`  |   32   |

#### リテラル
ソースコードに値を直接表記したものをリテラルという．

整数のためのリテラル定数には以下の種類がある．

- 10進数: `123`

    - `Long` 型を表すには `L` を付ける: `123L`

- 16進数: `0x0F`
- 2進数: `0b00001011`

注: 8進数はサポートされない．

Kotlin は一般的な浮動小数点数の表記法もサポートしている．

- デフォルトで `Double` 型: `123.5`, `123.5e10`
- `Float` 型を表すには `f` か `F` を付ける: `123.5f`

### 文字
文字は `Char` 型で表される．数値として直接扱うことはできない．

#### 文字リテラル
文字リテラルを表現するには，シングルクオートで囲む: `'a'`

特殊文字はバックスラッシュを使ってエスケープする．次のエスケープシーケンスがサポートされている:

| リテラル |             文字              |
| :------: | :---------------------------: |
|   `\b`   |        バックスペース         |
|   `\n`   |             改行              |
|   `\t`   |           タブ文字            |
|   `\'`   |       シングルクオート        |
|   `\"`   |        ダブルクオート         |
|   `\\`   |       バックスラッシュ        |
|   `\$`   |           ドル記号            |
| `\uXXXX` | 符号位置がU+XXXXのUnicode文字 |

### 真偽値
真偽値は `Boolean` 型で表され，`true` と `false` の2つの値がある．

### 配列
Kotlin では配列は `Array` 型で表される．配列を作るには，`arrayOf()` などに値を渡す: `arrayOf(1, 2, 3)`

`Array` には `T` が `Int` などの組み込み型の場合，特別なクラス（`IntArray` など）が用意されている．

配列の要素へのアクセスは `[]` を付ける．配列のインデックスは0から始まる:

```kt
val arr = arrayOf(1, 2, 3)
val a = arr[1] // a == 2
```

### 文字列
文字列は `String` 型で表される．配列のように `[]` を付けることで文字列の要素にアクセスすることができる．

#### 文字列リテラル
Kotlin には2種類の文字列リテラルがある．1つはエスケープされた文字列を持ちうる文字列で，もう1つはエスケープされない生文字列である．

```kt
val s = "Hello, World\n"
```

エスケープにはバックスラッシュを用いる．サポートされているエスケープシーケンスは[文字](#文字)を参照．

生文字列は三連クオート（`"""`）で囲う．生文字列ではエスケープは含まれず，改行や他の文字を含むことができる．

```kt
var text = """
fun main() {
    println("Hello, World!")
}
"""
```

#### 文字列テンプレート
文字列テンプレートでは式を埋め込むことができる:

```kt
val i = 10
val s = "i = $i" // "i = 10" と評価される
```

また，波括弧を使った記法もある:

```kt
val s = "abc"
val str = "$s.length is ${s.length}" // "abc.length is 3" と評価される
```

文字列テンプレートは生文字列でも使用できる．生文字列内で `$` を使いたいときは以下で表現することができる:

```kt
val price = """
${'$'}9.99
"""
```

## 変数
変数宣言には2種類存在する．どちらも `[キーワード] [変数名]: [型]` で表現される．

- 読み取り専用の変数

    ```kt
    val a: Int
    ```

- 変更可能な変数

    ```kt
    var a: Int
    ```

また，どちらも宣言と同時に初期化できる:

```kt
val a: Int = 0
```

これらの違いは再代入することができるかどうかである．`val` で宣言された変数でも[関数](#関数)を通して値を変更可能であるから，特に理由がない場合は `val` を使うことを推奨する．

Kotlin には型推論があるため，右辺から変数の型が分かるときは型を省略することができる:

```kt
val a = 0 // a は Int型
```

### `null` 許容型
型の名前の後ろに `?` を付けることでその変数が `null` であることを許す．

```kt
val a: Int
a = 0 // これはダメ

val b: Int?
b = null // これはできる
```

`null` 許容型の変数を使うときはその変数が `null` でないことを調べる必要がある．

## 関数
Kotlin の関数は `fun` キーワードを使って宣言する．関数のパラメータ及び返り値の型は `名前: 型` で定義される．:

```kt
fun double(x: Int): Int {
    return 2 * x
}
```

関数の呼び出しは名前の後に括弧を付ける:

```kt
val result = double(2)
```

### デフォルト引数
関数のパラメータは対応する引数が省略されているときに使用されるデフォルト値を持つことができる:

```kt
fun read(b: ByteArray, off: Int = 0, len: Int = b.size()) {
    ...
}
```

### 名前付き引数
関数を呼び出すとき，関数のパラメータに名前を付けることができる．これは関数が沢山のパラメータやデフォルトのパラメータを持つ場合に非常に便利である．

```kt
fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
...
}
```

デフォルト引数を用いることで以下のように書ける:

```kt
reformat(str)
```

例えば，`wordSeparator` だけを変更したい場合，関数の呼び出しは以下のようになる:

```kt
reformat(str, true, true, false, '_')
```

名前付き引数を用いることで簡単に書ける:

```kt
reformat(str, wordSeparator = '_')
```

### `Unit` を返す関数
関数が有用な値を返さない場合，その返り値の型は `Unit` になる．`Unit` は唯一の値だけを持つ型であり，この値は明示的に `return` する必要はない:

```kt
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi, there!")
    // `return Unit` または `return` は必須でない
}
```

`Unit` の宣言も必須でない．上記のコードは次と等価:

```kt
fun printHello(name: String?) {
    ...
}
```

### 単一式関数
関数がただ1つの式を返すとき，中括弧を省略することができ，本体は `=` の後に表される:

```kt
fun double(x: Int): Int = x * 2
```

返り値が推論できるときには，返り値の型は省略できる:

```kt
fun double(x: Int) = x * 2
```

### 明示的な返り値の型
`Unit` を返すことを意図していない限り，ブロックを持つ関数は常に明示的に返り値の型を指定しなければならない．
